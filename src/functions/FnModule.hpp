// Auto-generated by compile-delayed-module from ../src/functions/FnModule.xq
// DO NOT EDIT

// ../src/functions/FnModule.xq
static const XMLCh fn_file[] = { 46, 46, 47, 115, 114, 99, 47, 102, 117, 110, 99, 116, 105, 111, 110, 115, 47, 70, 110, 77, 111, 100, 117, 108, 101, 46, 120, 113, 0 };

// fn
static const XMLCh fn_prefix[] = { 102, 110, 0 };

// http://www.w3.org/2005/xpath-functions
static const XMLCh fn_uri[] = { 104, 116, 116, 112, 58, 47, 47, 119, 119, 119, 46, 119, 51, 46, 111, 114, 103, 47, 50, 48, 48, 53, 47, 120, 112, 97, 116, 104, 45, 102, 117, 110, 99, 116, 105, 111, 110, 115, 0 };

static const DelayedModule::FuncDef fn_functions[] = {
  {
    "data", 1, false, 20, 1,
    "declare function data($a as item()*) as xs:anyAtomicType*\n"
    "{\n"
    "  $a\n"
    "}\n"
  },
  {
    "string-join", 1, false, 28, 1,
    "declare function string-join($seq as xs:string*) as xs:string\n"
    "{\n"
    "  string-join($seq, \"\")\n"
    "}\n"
  },
  {
    "string-join", 2, false, 33, 1,
    "declare function string-join($seq as xs:string*, $join as xs:string) as xs:string\n"
    "{\n"
    "  if(empty($seq)) then \"\"\n"
    "  else string-join-helper($seq, $join)\n"
    "}\n"
  },
  {
    "string-join-helper", 2, true, 39, 1,
    "declare private function string-join-helper($seq as xs:string*, $join as xs:string) as xs:string\n"
    "{\n"
    "  if(empty(tail($seq))) then head($seq)\n"
    "  else concat(head($seq), $join, string-join-helper(tail($seq), $join))\n"
    "}\n"
  },
  {
    "substring-before", 2, false, 45, 1,
    "declare function substring-before($arg1 as xs:string?, $arg2 as xs:string?) as xs:string\n"
    "{\n"
    "  substring-before($arg1, $arg2, default-collation())\n"
    "}\n"
  },
  {
    "substring-before", 3, false, 50, 1,
    "declare function substring-before($arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  let $arg1 := if(empty($arg1)) then \"\" else $arg1\n"
    "  let $arg2 := if(empty($arg2)) then \"\" else $arg2\n"
    "  let $arg2len := string-length($arg2)\n"
    "  return\n"
    "    substring($arg1, 1,\n"
    "      string-index-of($arg1, 1, 1 + string-length($arg1) - $arg2len, $arg2, $arg2len, $collation) - 1)\n"
    "}\n"
  },
  {
    "substring-after", 2, false, 61, 1,
    "declare function substring-after($arg1 as xs:string?, $arg2 as xs:string?) as xs:string\n"
    "{\n"
    "  substring-after($arg1, $arg2, default-collation())\n"
    "}\n"
  },
  {
    "substring-after", 3, false, 66, 1,
    "declare function substring-after($arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  let $arg1 := if(empty($arg1)) then \"\" else $arg1\n"
    "  let $arg2 := if(empty($arg2)) then \"\" else $arg2\n"
    "  let $arg2len := string-length($arg2)\n"
    "  let $index := string-index-of($arg1, 1, 1 + string-length($arg1) - $arg2len, $arg2, $arg2len, $collation)\n"
    "  return\n"
    "    if($index eq 0) then \"\" else substring($arg1, $index + $arg2len)\n"
    "}\n"
  },
  {
    "string-index-of", 6, true, 77, 1,
    "declare private function string-index-of($str as xs:string, $index as xs:decimal, $endindex as xs:decimal,\n"
    "  $tofind as xs:string, $tofindlen as xs:decimal, $collation as xs:string) as xs:decimal\n"
    "{\n"
    "  if($index gt $endindex) then 0\n"
    "  else if(compare($tofind, substring($str, $index, $tofindlen), $collation) eq 0) then $index\n"
    "  else string-index-of($str, $index + 1, $endindex, $tofind, $tofindlen, $collation)\n"
    "}\n"
  },
  {
    "codepoint-equal", 2, false, 85, 1,
    "declare function codepoint-equal($arg1 as xs:string?, $arg2 as xs:string?) as xs:boolean?\n"
    "{\n"
    "  if(empty($arg1) or empty($arg2)) then ()\n"
    "  else compare($arg1, $arg2, \"http://www.w3.org/2005/xpath-functions/collation/codepoint\") eq 0\n"
    "}\n"
  },
  {
    "translate", 3, false, 91, 1,
    "declare function translate($arg as xs:string?, $mapString as xs:string, $transString as xs:string) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    let $in := string-to-codepoints($arg)\n"
    "    let $map := string-to-codepoints($mapString)\n"
    "    let $trans := string-to-codepoints($transString)\n"
    "    for $c in $in\n"
    "    let $index := head(index-of($map, $c))\n"
    "    return\n"
    "      if(empty($index)) then $c else $trans[$index]\n"
    "  )\n"
    "}\n"
  },
  {
    "codepoint-in-utf8", 1, true, 104, 1,
    "declare private function codepoint-in-utf8($c as xs:integer) as xs:integer+\n"
    "{\n"
    "  if($c < 128) then $c\n"
    "  else if($c < 2048) then (\n"
    "    ($c idiv 64) + 192,\n"
    "    ($c mod 64) + 128\n"
    "  )\n"
    "  else if($c < 65536) then (\n"
    "    ($c idiv 4096) + 224,\n"
    "    (($c idiv 64) mod 64) + 128,\n"
    "    ($c mod 64) + 128\n"
    "  )\n"
    "  else (\n"
    "    ($c idiv 262144) + 240,\n"
    "    (($c idiv 4096) mod 64) + 128,\n"
    "    (($c idiv 64) mod 64) + 128,\n"
    "    ($c mod 64) + 128\n"
    "  )\n"
    "}\n"
  },
  {
    "percent-encode", 1, true, 124, 1,
    "declare private function percent-encode($c as xs:integer) as xs:integer+\n"
    "{\n"
    "  (: Codepoint for \"%\" :)\n"
    "  let $percent := 37\n"
    "  (: Codepoints for \"0\" - \"9\", \"A\" - \"F\" :)\n"
    "  let $hex := (48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70)\n"
    "  for $byte in codepoint-in-utf8($c)\n"
    "  return (\n"
    "    $percent,\n"
    "    $hex[($byte idiv 16) + 1],\n"
    "    $hex[($byte mod 16) + 1]\n"
    "  )\n"
    "}\n"
  },
  {
    "encode-for-uri", 1, false, 138, 1,
    "declare function encode-for-uri($uri-part as xs:string?) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    let $A := string-to-codepoints(\"A\")\n"
    "    let $Z := string-to-codepoints(\"Z\")\n"
    "    let $a := string-to-codepoints(\"a\")\n"
    "    let $z := string-to-codepoints(\"z\")\n"
    "    let $d0 := string-to-codepoints(\"0\")\n"
    "    let $d9 := string-to-codepoints(\"9\")\n"
    "    let $hyphen := string-to-codepoints(\"-\")\n"
    "    let $underscore := string-to-codepoints(\"_\")\n"
    "    let $fullstop := string-to-codepoints(\".\")\n"
    "    let $tilde := string-to-codepoints(\"~\")\n"
    "\n"
    "    for $c in string-to-codepoints($uri-part)\n"
    "    return\n"
    "      if(($c ge $A and $c le $Z) or\n"
    "        ($c ge $a and $c le $z) or\n"
    "        ($c ge $d0 and $c le $d9) or\n"
    "        $c eq $hyphen or $c eq $underscore or\n"
    "        $c eq $fullstop or $c eq $tilde)\n"
    "      then $c\n"
    "      else percent-encode($c)\n"
    "  )\n"
    "}\n"
  },
  {
    "iri-to-uri", 1, false, 164, 1,
    "declare function iri-to-uri($iri as xs:string?) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    let $leftangle := string-to-codepoints(\"<\")\n"
    "    let $rightangle := string-to-codepoints(\">\")\n"
    "    let $doublequote := string-to-codepoints('\"')\n"
    "    let $space := string-to-codepoints(\" \")\n"
    "    let $leftcurly := string-to-codepoints(\"{\")\n"
    "    let $rightcurly := string-to-codepoints(\"}\")\n"
    "    let $bar := string-to-codepoints(\"|\")\n"
    "    let $backslash := 92\n"
    "    let $hat := string-to-codepoints(\"^\")\n"
    "    let $backtick := string-to-codepoints(\"`\")\n"
    "\n"
    "    for $c in string-to-codepoints($iri)\n"
    "    return\n"
    "      if($c lt 32 or $c gt 126 or\n"
    "        $c eq $leftangle or $c eq $rightangle or\n"
    "        $c eq $doublequote or $c eq $space or\n"
    "        $c eq $leftcurly or $c eq $rightcurly or\n"
    "        $c eq $bar or $c eq $backslash or\n"
    "        $c eq $hat or $c eq $backtick)\n"
    "      then percent-encode($c)\n"
    "      else $c\n"
    "  )\n"
    "}\n"
  },
  {
    "escape-html-uri", 1, false, 191, 1,
    "declare function escape-html-uri($iri as xs:string?) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    for $c in string-to-codepoints($iri)\n"
    "    return\n"
    "      if($c lt 32 or $c gt 126)\n"
    "      then percent-encode($c)\n"
    "      else $c\n"
    "  )\n"
    "}\n"
  },
  {
    "resolve-QName", 2, false, 205, 1,
    "declare function resolve-QName($qname as xs:string?, $element as element()) as xs:QName?\n"
    "{\n"
    "  typeswitch($qname)\n"
    "  case $qname as xs:string return\n"
    "    let $mock := QName(\"dummy\", $qname)\n"
    "    let $uri := namespace-uri-for-prefix(prefix-from-QName($mock), $element)\n"
    "    return\n"
    "      if(empty(prefix-from-QName($mock)) or exists($uri)) then QName($uri, $qname)\n"
    "      else error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FONS0004\"),\n"
    "        concat(\"No namespace found for prefix: \"\"\", prefix-from-QName($mock), \"\"\"\"))\n"
    "  default return ()\n"
    "}\n"
  },
  {
    "namespace-uri-for-prefix", 2, false, 218, 1,
    "declare function namespace-uri-for-prefix($prefix as xs:string?, $element as element()) as xs:anyURI?\n"
    "{\n"
    "  let $prefix := if(empty($prefix)) then \"\" else $prefix\n"
    "  return $element/namespace::*[name() eq $prefix]/xs:anyURI(.)\n"
    "}\n"
  },
  {
    "in-scope-prefixes", 1, false, 224, 1,
    "declare function in-scope-prefixes($element as element()) as xs:string*\n"
    "{\n"
    "  $element/namespace::*/name()\n"
    "}\n"
  },
  {
    "true", 0, false, 232, 1,
    "declare function true() as xs:boolean\n"
    "{\n"
    "  xs:boolean(\"1\")\n"
    "}\n"
  },
  {
    "false", 0, false, 237, 1,
    "declare function false() as xs:boolean\n"
    "{\n"
    "  xs:boolean(\"0\")\n"
    "}\n"
  },
  {
    "boolean", 1, false, 242, 1,
    "declare function boolean($arg as item()*) as xs:boolean\n"
    "{\n"
    "  $arg and true()\n"
    "}\n"
  },
  {
    "zero-or-one", 1, false, 250, 1,
    "declare function zero-or-one($arg as item()*) as item()?\n"
    "{\n"
    "  typeswitch($arg)\n"
    "  case $arg_ as item()? return $arg_\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0003\"),\n"
    "    \"Sequence contains more then one item\")\n"
    "}\n"
  },
  {
    "one-or-more", 1, false, 258, 1,
    "declare function one-or-more($arg as item()*) as item()+\n"
    "{\n"
    "  typeswitch($arg)\n"
    "  case $arg_ as item()+ return $arg_\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0004\"),\n"
    "    \"Sequence is empty\")\n"
    "}\n"
  },
  {
    "exactly-one", 1, false, 266, 1,
    "declare function exactly-one($arg as item()*) as item()\n"
    "{\n"
    "  typeswitch($arg)\n"
    "  case $arg_ as item() return $arg_\n"
    "  case empty-sequence() return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0005\"),\n"
    "    \"Sequence is empty\")\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0005\"),\n"
    "    \"Sequence contains more then one item\")\n"
    "}\n"
  },
  {
    "index-of", 2, false, 276, 1,
    "declare function index-of($seq as xs:anyAtomicType*, $search as xs:anyAtomicType) as xs:integer*\n"
    "{\n"
    "  (: Check for NaN :)\n"
    "  if($search ne $search) then () else index-of-helper($seq, $search, default-collation())\n"
    "}\n"
  },
  {
    "index-of", 3, false, 282, 1,
    "declare function index-of($seq as xs:anyAtomicType*, $search as xs:anyAtomicType,\n"
    "   $collation as xs:string) as xs:integer*\n"
    "{\n"
    "  (: Check for NaN :)\n"
    "  if($search ne $search) then () else index-of-helper($seq, $search, $collation)\n"
    "}\n"
  },
  {
    "index-of-helper", 3, true, 289, 1,
    "declare private function index-of-helper($seq as xs:anyAtomicType*, $search as xs:anyAtomicType,\n"
    "  $collation as xs:string) as xs:integer*\n"
    "{\n"
    "  for $s at $p in $seq\n"
    "  where empty(tail(distinct-values(($s, $search), $collation)))\n"
    "  return $p\n"
    "}\n"
  },
  {
    "insert-before", 3, false, 297, 1,
    "declare function insert-before($target as item()*, $position as xs:integer, $inserts as item()*)\n"
    "  as item()*\n"
    "{\n"
    "  if($position le 1 or empty($inserts)) then ($inserts, $target)\n"
    "  else (head($target), insert-before(tail($target), $position - 1, $inserts))\n"
    "}\n"
  },
  {
    "remove", 2, false, 304, 1,
    "declare function remove($target as item()*, $position as xs:integer) as item()*\n"
    "{\n"
    "  $target[position() ne $position]\n"
    "}\n"
  },
  {
    "reverse", 1, false, 309, 1,
    "declare function reverse($seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then ()\n"
    "  else (reverse(tail($seq)), head($seq))\n"
    "}\n"
  },
  {
    "subsequence", 2, false, 315, 1,
    "declare function subsequence($sourceSeq as item()*, $startingLoc as xs:double) as item()*\n"
    "{\n"
    "  subsequence-helper($sourceSeq, round($startingLoc))\n"
    "}\n"
  },
  {
    "subsequence", 3, false, 320, 1,
    "declare function subsequence($sourceSeq as item()*, $startingLoc as xs:double,\n"
    "  $length as xs:double) as item()*\n"
    "{\n"
    "  let $start := round($startingLoc)\n"
    "  return subsequence-helper($sourceSeq, $start, $start + round($length))\n"
    "}\n"
  },
  {
    "subsequence-helper", 2, true, 327, 1,
    "declare private function subsequence-helper($seq as item()*, $start as xs:double) as item()*\n"
    "{\n"
    "  if($start le 1) then $seq\n"
    "  else subsequence-helper(tail($seq), $start - 1)\n"
    "}\n"
  },
  {
    "subsequence-helper", 3, true, 333, 1,
    "declare private function subsequence-helper($seq as item()*, $start as xs:double,\n"
    "  $end as xs:double) as item()*\n"
    "{\n"
    "  if($end le 1) then ()\n"
    "  else (\n"
    "    if($start le 1) then head($seq) else (),\n"
    "    subsequence-helper(tail($seq), $start - 1, $end - 1)\n"
    "  )\n"
    "}\n"
  },
  {
    "deep-equal", 2, false, 343, 1,
    "declare function deep-equal($parameter1 as item()*, $parameter2 as item()*) as xs:boolean\n"
    "{\n"
    "  deep-equal($parameter1, $parameter2, default-collation())\n"
    "}\n"
  },
  {
    "deep-equal", 3, false, 348, 1,
    "declare function deep-equal($p1 as item()*, $p2 as item()*, $collation as xs:string) as xs:boolean\n"
    "{\n"
    "  if(empty($p1)) then empty($p2) else\n"
    "  if(empty($p2)) then false() else\n"
    "\n"
    "  let $i1 := head($p1), $i2 := head($p2)\n"
    "  return\n"
    "    typeswitch($i1)\n"
    "\n"
    "    case $a1 as xs:anyAtomicType return\n"
    "      typeswitch($i2)\n"
    "      case $a2 as xs:anyAtomicType return\n"
    "        empty(tail(distinct-values(($a1, $a2), $collation))) and\n"
    "        deep-equal(tail($p1), tail($p2), $collation)\n"
    "      case node() return false()\n"
    "      default return deep-equal-error()\n"
    "\n"
    "    case $n1 as node() return (\n"
    "      typeswitch($i2)\n"
    "      case xs:anyAtomicType return false()\n"
    "      case $n2 as node() return (\n"
    "        deep-equal-nodes($n1, $n2, $collation) and\n"
    "        deep-equal(tail($p1), tail($p2), $collation)\n"
    "      )\n"
    "      default return deep-equal-error()\n"
    "    )\n"
    "\n"
    "    default return deep-equal-error()\n"
    "}\n"
  },
  {
    "deep-equal-error", 0, true, 378, 1,
    "declare private function deep-equal-error()\n"
    "{\n"
    "  error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FOTY0015\"),\n"
    "    \"An argument to fn:deep-equal() contains a function item\")\n"
    "}\n"
  },
  {
    "deep-equal-nodes", 3, true, 384, 1,
    "declare private function deep-equal-nodes($p1 as node()*, $p2 as node()*, $collation as xs:string) as xs:boolean\n"
    "{\n"
    "  if(empty($p1)) then empty($p2) else\n"
    "  if(empty($p2)) then false() else\n"
    "\n"
    "  let $i1 := head($p1), $i2 := head($p2)\n"
    "  return\n"
    "  typeswitch($i1)\n"
    "\n"
    "  case document-node() return\n"
    "    typeswitch($i2)\n"
    "    case document-node() return\n"
    "      deep-equal-nodes($i1/(*|text()), $i2/(*|text()), $collation) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case text() return\n"
    "    typeswitch($i2)\n"
    "    case text() return\n"
    "      empty(tail(distinct-values(($i1, $i2), $collation))) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case comment() return\n"
    "    typeswitch($i2)\n"
    "    case comment() return\n"
    "      empty(tail(distinct-values(($i1, $i2), $collation))) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case processing-instruction() return\n"
    "    typeswitch($i2)\n"
    "    case processing-instruction() return\n"
    "      node-name($i1) eq node-name($i2) and\n"
    "      empty(tail(distinct-values(($i1, $i2), $collation))) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case attribute() return\n"
    "    typeswitch($i2)\n"
    "    case attribute() return\n"
    "      node-name($i1) eq node-name($i2) and\n"
    "      deep-equal(data($i1), data($i2), $collation) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case element() return\n"
    "    typeswitch($i2)\n"
    "    case element() return (\n"
    "      node-name($i1) eq node-name($i2) and\n"
    "      count($i1/@*) eq count($i2/@*) and\n"
    "      (every $a1 in $i1/@* satisfies\n"
    "        some $a2 in $i2/@* satisfies deep-equal-nodes($a1, $a2, $collation)) and\n"
    "\n"
    "      (if(empty($i1/*) and empty($i2/*))\n"
    "        then deep-equal(data($i1), data($i2), $collation)\n"
    "        else deep-equal-nodes($i1/(*|text()), $i2/(*|text()), $collation)) and\n"
    "\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    )\n"
    "    default return false()\n"
    "\n"
    "  \n"
    "  default (: namespace-node() :) return\n"
    "    typeswitch($i2)\n"
    "    case document-node() return false()\n"
    "    case element() return false()\n"
    "    case attribute() return false()\n"
    "    case processing-instruction() return false()\n"
    "    case comment() return false()\n"
    "    case text() return false()\n"
    "    default (: namespace-node() :) return\n"
    "      deep-equal(node-name($i1), node-name($i2), $collation) and\n"
    "      codepoint-equal($i1, $i2) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "}\n"
  },
  {
    "avg", 1, false, 464, 1,
    "declare function avg($arg as xs:anyAtomicType*) as xs:anyAtomicType?\n"
    "{\n"
    "  sum($arg, ()) div count($arg)\n"
    "}\n"
  },
  {
    "sum", 1, false, 469, 1,
    "declare function sum($arg as xs:anyAtomicType*) as xs:anyAtomicType\n"
    "{\n"
    "  sum($arg, 0)\n"
    "}\n"
  },
  {
    "sum", 2, false, 474, 1,
    "declare function sum($arg as xs:anyAtomicType*, $zero as xs:anyAtomicType?) as xs:anyAtomicType?\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $zero\n"
    "  case $head as xs:untypedAtomic return numeric-sum(tail($arg), xs:double($head))\n"
    "  case $head as xs:double return if($head ne $head) then $head else numeric-sum(tail($arg), $head)\n"
    "  case $head as xs:float return if($head ne $head) then $head else numeric-sum(tail($arg), $head)\n"
    "  case $head as xs:decimal return numeric-sum(tail($arg), $head)\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-sum(tail($arg), $head)\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-sum(tail($arg), $head)\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0006\"),\n"
    "    \"Invalid argument to fn:sum() function\")\n"
    "}\n"
  },
  {
    "numeric-sum", 2, true, 488, 1,
    "declare private function numeric-sum($arg as xs:anyAtomicType*, $result as xs:anyAtomicType) as xs:anyAtomicType\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic return numeric-sum(tail($arg), xs:double($head) + $result)\n"
    "  case $head as xs:double return if($head ne $head) then $head else numeric-sum(tail($arg), $head + $result)\n"
    "  case $head as xs:float return if($head ne $head) then $head else numeric-sum(tail($arg), $head + $result)\n"
    "  case $head as xs:decimal return numeric-sum(tail($arg), $head + $result)\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0006\"),\n"
    "    \"Invalid argument to fn:sum() function\")\n"
    "}\n"
  },
  {
    "yearMonthDuration-sum", 2, true, 500, 1,
    "declare private function yearMonthDuration-sum($arg as xs:anyAtomicType*, $result as xs:yearMonthDuration) as xs:yearMonthDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-sum(tail($arg), $head + $result)\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0006\"),\n"
    "    \"Invalid argument to fn:sum() function\")\n"
    "}\n"
  },
  {
    "dayTimeDuration-sum", 2, true, 509, 1,
    "declare private function dayTimeDuration-sum($arg as xs:anyAtomicType*, $result as xs:dayTimeDuration) as xs:dayTimeDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-sum(tail($arg), $head + $result)\n"
    "  default return error(QName(\"http://www.w3.org/2005/xqt-errors\", \"err:FORG0006\"),\n"
    "    \"Invalid argument to fn:sum() function\")\n"
    "}\n"
  },
  {
    "map", 2, false, 523, 1,
    "declare function map($f as function(item()) as item()*, $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then ()\n"
    "  else $f(head($seq)), map($f, tail($seq))\n"
    "}\n"
  },
  {
    "filter", 2, false, 529, 1,
    "declare function filter($f as function(item()) as xs:boolean, $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then ()\n"
    "  else (\n"
    "    if($f(head($seq))) then head($seq) else (),\n"
    "    filter($f, tail($seq))\n"
    "  )\n"
    "}\n"
  },
  {
    "fold-left", 3, false, 538, 1,
    "declare function fold-left($f as function(item()*, item()) as item()*, $zero as item()*,\n"
    "  $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then $zero\n"
    "  else fold-left($f, $f($zero, head($seq)), tail($seq))\n"
    "}\n"
  },
  {
    "fold-right", 3, false, 545, 1,
    "declare function fold-right($f as function(item()*, item()) as item()*, $zero as item()*,\n"
    "  $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then $zero\n"
    "  else $f(head($seq), fold-right($f, $zero, tail($seq)))\n"
    "}\n"
  },
  {
    "map-pairs", 3, false, 552, 1,
    "declare function map-pairs($f as function(item(), item()) as item()*, $seq1 as item()*,\n"
    "  $seq2 as item()*) as item()*\n"
    "{\n"
    "   if(exists($seq1) and exists($seq2))\n"
    "   then (\n"
    "     $f(head($seq1), head($seq2)),\n"
    "     map-pairs($f, tail($seq1), tail($seq2))\n"
    "   )\n"
    "   else ()\n"
    "}\n"
  },
  { 0, 0, 0, 0, 0 }
};

static const DelayedModule fn_module = { fn_file, fn_prefix, fn_uri, fn_functions };
