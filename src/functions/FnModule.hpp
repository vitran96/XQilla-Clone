// Auto-generated by compile-delayed-module from ../src/functions/FnModule.xq
// DO NOT EDIT

// ../src/functions/FnModule.xq
static const XMLCh fn_file[] = { 46, 46, 47, 115, 114, 99, 47, 102, 117, 110, 99, 116, 105, 111, 110, 115, 47, 70, 110, 77, 111, 100, 117, 108, 101, 46, 120, 113, 0 };

// fn
static const XMLCh fn_prefix[] = { 102, 110, 0 };

// http://www.w3.org/2005/xpath-functions
static const XMLCh fn_uri[] = { 104, 116, 116, 112, 58, 47, 47, 119, 119, 119, 46, 119, 51, 46, 111, 114, 103, 47, 50, 48, 48, 53, 47, 120, 112, 97, 116, 104, 45, 102, 117, 110, 99, 116, 105, 111, 110, 115, 0 };

static const DelayedModule::Decl fn_declarations[] = {
  {
    DelayedModule::Decl::NAMESPACE, "rw", 0, false, 24, 1,
    "http://xqilla.sourceforge.net/rewrite"
  },
  {
    DelayedModule::Decl::NAMESPACE, "math", 0, false, 25, 1,
    "http://www.w3.org/2005/xpath-functions/math"
  },
  {
    DelayedModule::Decl::FUNCTION, "data", 1, false, 27, 1,
    "declare function data($a as item()*) as xs:anyAtomicType*\n"
    "{\n"
    "  $a\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "string-join", 1, false, 35, 1,
    "declare %xqilla:inline\n"
    "function string-join($seq as xs:string*) as xs:string\n"
    "{\n"
    "  string-join($seq, \"\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "string-join", 2, false, 41, 1,
    "declare %xqilla:inline\n"
    "function string-join($seq as xs:string*, $join as xs:string) as xs:string\n"
    "{\n"
    "  if(empty($seq)) then \"\"\n"
    "  else string-join-helper($seq, $join)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "string-join-helper", 2, true, 48, 1,
    "declare %private function string-join-helper($seq as xs:string*, $join as xs:string) as xs:string\n"
    "{\n"
    "  if(empty(tail($seq))) then head($seq)\n"
    "  else concat(head($seq), $join, string-join-helper(tail($seq), $join))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "substring-before", 2, false, 54, 1,
    "declare %xqilla:inline\n"
    "function substring-before($arg1 as xs:string?, $arg2 as xs:string?) as xs:string\n"
    "{\n"
    "  substring-before($arg1, $arg2, default-collation())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "substring-before", 3, false, 60, 1,
    "declare function substring-before($arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  let $arg1 := if(empty($arg1)) then \"\" else $arg1\n"
    "  let $arg2 := if(empty($arg2)) then \"\" else $arg2\n"
    "  let $arg2len := string-length($arg2)\n"
    "  return\n"
    "    substring($arg1, 1,\n"
    "      string-index-of($arg1, 1, 1 + string-length($arg1) - $arg2len, $arg2, $arg2len, $collation) - 1)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "substring-after", 2, false, 71, 1,
    "declare %xqilla:inline\n"
    "function substring-after($arg1 as xs:string?, $arg2 as xs:string?) as xs:string\n"
    "{\n"
    "  substring-after($arg1, $arg2, default-collation())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "substring-after", 3, false, 77, 1,
    "declare function substring-after($arg1 as xs:string?, $arg2 as xs:string?, $collation as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  let $arg1 := if(empty($arg1)) then \"\" else $arg1\n"
    "  let $arg2 := if(empty($arg2)) then \"\" else $arg2\n"
    "  let $arg2len := string-length($arg2)\n"
    "  let $index := string-index-of($arg1, 1, 1 + string-length($arg1) - $arg2len, $arg2, $arg2len, $collation)\n"
    "  return\n"
    "    if($index eq 0) then \"\" else substring($arg1, $index + $arg2len)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "string-index-of", 6, true, 88, 1,
    "declare %private function string-index-of($str as xs:string, $index as xs:decimal, $endindex as xs:decimal,\n"
    "  $tofind as xs:string, $tofindlen as xs:decimal, $collation as xs:string) as xs:decimal\n"
    "{\n"
    "  if($index gt $endindex) then 0\n"
    "  else if(compare($tofind, substring($str, $index, $tofindlen), $collation) eq 0) then $index\n"
    "  else string-index-of($str, $index + 1, $endindex, $tofind, $tofindlen, $collation)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "codepoint-equal", 2, false, 96, 1,
    "declare %xqilla:inline\n"
    "function codepoint-equal($arg1 as xs:string?, $arg2 as xs:string?) as xs:boolean?\n"
    "{\n"
    "  compare($arg1, $arg2, \"http://www.w3.org/2005/xpath-functions/collation/codepoint\") eq 0\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "translate", 3, false, 102, 1,
    "declare function translate($arg as xs:string?, $mapString as xs:string, $transString as xs:string) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    let $in := string-to-codepoints($arg)\n"
    "    let $map := string-to-codepoints($mapString)\n"
    "    let $trans := string-to-codepoints($transString)\n"
    "    for $c in $in\n"
    "    let $index := head(index-of($map, $c))\n"
    "    return\n"
    "      if(empty($index)) then $c else $trans[$index]\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "codepoint-in-utf8", 1, true, 115, 1,
    "declare %private function codepoint-in-utf8($c as xs:integer) as xs:integer+\n"
    "{\n"
    "  if($c < 128) then $c\n"
    "  else if($c < 2048) then (\n"
    "    ($c idiv 64) + 192,\n"
    "    ($c mod 64) + 128\n"
    "  )\n"
    "  else if($c < 65536) then (\n"
    "    ($c idiv 4096) + 224,\n"
    "    (($c idiv 64) mod 64) + 128,\n"
    "    ($c mod 64) + 128\n"
    "  )\n"
    "  else (\n"
    "    ($c idiv 262144) + 240,\n"
    "    (($c idiv 4096) mod 64) + 128,\n"
    "    (($c idiv 64) mod 64) + 128,\n"
    "    ($c mod 64) + 128\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "percent-encode", 1, true, 135, 1,
    "declare %private function percent-encode($c as xs:integer) as xs:integer+\n"
    "{\n"
    "  (: Codepoint for \"%\" :)\n"
    "  let $percent := 37\n"
    "  (: Codepoints for \"0\" - \"9\", \"A\" - \"F\" :)\n"
    "  let $hex := (48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70)\n"
    "  for $byte in codepoint-in-utf8($c)\n"
    "  return (\n"
    "    $percent,\n"
    "    $hex[($byte idiv 16) + 1],\n"
    "    $hex[($byte mod 16) + 1]\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "encode-for-uri", 1, false, 149, 1,
    "declare function encode-for-uri($uri-part as xs:string?) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    let $A := string-to-codepoints(\"A\")\n"
    "    let $Z := string-to-codepoints(\"Z\")\n"
    "    let $a := string-to-codepoints(\"a\")\n"
    "    let $z := string-to-codepoints(\"z\")\n"
    "    let $d0 := string-to-codepoints(\"0\")\n"
    "    let $d9 := string-to-codepoints(\"9\")\n"
    "    let $hyphen := string-to-codepoints(\"-\")\n"
    "    let $underscore := string-to-codepoints(\"_\")\n"
    "    let $fullstop := string-to-codepoints(\".\")\n"
    "    let $tilde := string-to-codepoints(\"~\")\n"
    "\n"
    "    for $c in string-to-codepoints($uri-part)\n"
    "    return\n"
    "      if(($c ge $A and $c le $Z) or\n"
    "        ($c ge $a and $c le $z) or\n"
    "        ($c ge $d0 and $c le $d9) or\n"
    "        $c eq $hyphen or $c eq $underscore or\n"
    "        $c eq $fullstop or $c eq $tilde)\n"
    "      then $c\n"
    "      else percent-encode($c)\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "iri-to-uri", 1, false, 175, 1,
    "declare function iri-to-uri($iri as xs:string?) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    let $leftangle := string-to-codepoints(\"<\")\n"
    "    let $rightangle := string-to-codepoints(\">\")\n"
    "    let $doublequote := string-to-codepoints('\"')\n"
    "    let $space := string-to-codepoints(\" \")\n"
    "    let $leftcurly := string-to-codepoints(\"{\")\n"
    "    let $rightcurly := string-to-codepoints(\"}\")\n"
    "    let $bar := string-to-codepoints(\"|\")\n"
    "    let $backslash := 92\n"
    "    let $hat := string-to-codepoints(\"^\")\n"
    "    let $backtick := string-to-codepoints(\"`\")\n"
    "\n"
    "    for $c in string-to-codepoints($iri)\n"
    "    return\n"
    "      if($c lt 32 or $c gt 126 or\n"
    "        $c eq $leftangle or $c eq $rightangle or\n"
    "        $c eq $doublequote or $c eq $space or\n"
    "        $c eq $leftcurly or $c eq $rightcurly or\n"
    "        $c eq $bar or $c eq $backslash or\n"
    "        $c eq $hat or $c eq $backtick)\n"
    "      then percent-encode($c)\n"
    "      else $c\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "escape-html-uri", 1, false, 202, 1,
    "declare function escape-html-uri($iri as xs:string?) as xs:string\n"
    "{\n"
    "  codepoints-to-string(\n"
    "    for $c in string-to-codepoints($iri)\n"
    "    return\n"
    "      if($c lt 32 or $c gt 126)\n"
    "      then percent-encode($c)\n"
    "      else $c\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "resolve-QName", 2, false, 216, 1,
    "declare function resolve-QName($qname as xs:string?, $element as element()) as xs:QName?\n"
    "{\n"
    "  typeswitch($qname)\n"
    "  case $qname as xs:string return\n"
    "    let $mock := QName(\"dummy\", $qname)\n"
    "    let $uri := namespace-uri-for-prefix(prefix-from-QName($mock), $element)\n"
    "    return\n"
    "      if(empty(prefix-from-QName($mock)) or exists($uri)) then QName($uri, $qname)\n"
    "      else error(xs:QName(\"err:FONS0004\"), concat(\"No namespace found for prefix: \"\"\", prefix-from-QName($mock), \"\"\"\"))\n"
    "  default return ()\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "namespace-uri-for-prefix", 2, false, 228, 1,
    "declare function namespace-uri-for-prefix($prefix as xs:string?, $element as element()) as xs:anyURI?\n"
    "{\n"
    "  let $prefix := if(empty($prefix)) then \"\" else $prefix\n"
    "  return $element/namespace::*[name() eq $prefix]/xs:anyURI(.)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "in-scope-prefixes", 1, false, 234, 1,
    "declare function in-scope-prefixes($element as element()) as xs:string*\n"
    "{\n"
    "  $element/namespace::*/name()\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "true", 0, false, 242, 1,
    "declare %xqilla:inline\n"
    "function true() as xs:boolean\n"
    "{\n"
    "  xs:boolean(\"1\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "false", 0, false, 248, 1,
    "declare %xqilla:inline\n"
    "function false() as xs:boolean\n"
    "{\n"
    "  xs:boolean(\"0\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "boolean", 1, false, 254, 1,
    "declare %xqilla:inline\n"
    "function boolean($arg as item()*) as xs:boolean\n"
    "{\n"
    "  $arg and true()\n"
    "}"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 260, 25,
    "fn:EBVFold: boolean(~e)\n"
    "-> false() where rw:subtype(~e, 'empty-sequence()')\n"
    "-> exists(~e) where rw:subtype(~e, 'node()*')\n"
    "-> ~e where rw:subtype(~e, 'xs:boolean?')"
  },
  {
    DelayedModule::Decl::FUNCTION, "exists", 1, false, 265, 1,
    "declare %xqilla:inline\n"
    "function exists($arg as item()*) as xs:boolean\n"
    "{\n"
    "  not(empty($arg))\n"
    "}"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 271, 25,
    "fn:CountEqZero:\n"
    "count(~e) eq 0 -> empty(~e)"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 273, 25,
    "fn:CountNeZero:\n"
    "count(~e) ne 0 -> exists(~e)"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 275, 25,
    "fn:CountGtZero:\n"
    "count(~e) gt 0 -> exists(tail(~e))"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 278, 25,
    "fn:FnEmptyFold: empty(~e)\n"
    "-> false() where rw:subtype(~e, 'item()+')\n"
    "-> true() where rw:subtype(~e, 'empty-sequence()')"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 282, 25,
    "fn:AndTrueFold:  ~e and true()  -> ~e"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 283, 25,
    "fn:AndFalseFold: ~e and false() -> false()"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 284, 25,
    "fn:OrTrueFold:   ~e or  true()  -> true()"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 285, 25,
    "fn:OrFalseFold:  ~e or  false() -> ~e"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 287, 25,
    "fn:PredTypeAnalysis: ~e[~p]\n"
    "-> ~e[boolean(~p)] where (rw:never-subtype(~p, 'xs:decimal') and rw:never-subtype(~p, 'xs:float') and\n"
    "  rw:never-subtype(~p, 'xs:double') and rw:never-subtype(~p, 'xs:boolean'))"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 296, 25,
    "fn:PredTrueFold: ~e[true()] -> ~e"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 297, 25,
    "fn:PredFalseFold: ~e[false()] -> ()"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 298, 25,
    "fn:PredEmptyFold: ()[~e] -> ()"
  },
  {
    DelayedModule::Decl::FUNCTION, "zero-or-one", 1, false, 303, 1,
    "declare function zero-or-one($arg as item()*) as item()?\n"
    "{\n"
    "  typeswitch($arg)\n"
    "  case $arg_ as item()? return $arg_\n"
    "  default return error(xs:QName(\"err:FORG0003\"), \"Sequence contains more then one item\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "one-or-more", 1, false, 310, 1,
    "declare function one-or-more($arg as item()*) as item()+\n"
    "{\n"
    "  typeswitch($arg)\n"
    "  case $arg_ as item()+ return $arg_\n"
    "  default return error(xs:QName(\"err:FORG0004\"), \"Sequence is empty\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "exactly-one", 1, false, 317, 1,
    "declare function exactly-one($arg as item()*) as item()\n"
    "{\n"
    "  typeswitch($arg)\n"
    "  case $arg_ as item() return $arg_\n"
    "  case empty-sequence() return error(xs:QName(\"err:FORG0005\"), \"Sequence is empty\")\n"
    "  default return error(xs:QName(\"err:FORG0005\"), \"Sequence contains more then one item\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "index-of", 2, false, 325, 1,
    "declare %xqilla:inline\n"
    "function index-of($seq as xs:anyAtomicType*, $search as xs:anyAtomicType) as xs:integer*\n"
    "{\n"
    "  (: Check for NaN :)\n"
    "  if($search ne $search) then () else index-of-helper($seq, $search, default-collation())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "index-of", 3, false, 332, 1,
    "declare %xqilla:inline\n"
    "function index-of($seq as xs:anyAtomicType*, $search as xs:anyAtomicType,\n"
    "   $collation as xs:string) as xs:integer*\n"
    "{\n"
    "  (: Check for NaN :)\n"
    "  if($search ne $search) then () else index-of-helper($seq, $search, $collation)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "index-of-helper", 3, true, 340, 1,
    "declare %private function index-of-helper($seq as xs:anyAtomicType*, $search as xs:anyAtomicType,\n"
    "  $collation as xs:string) as xs:integer*\n"
    "{\n"
    "  for $s at $p in $seq\n"
    "  where empty(tail(distinct-values(($s, $search), $collation)))\n"
    "  return $p\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "insert-before", 3, false, 348, 1,
    "declare function insert-before($target as item()*, $position as xs:integer, $inserts as item()*)\n"
    "  as item()*\n"
    "{\n"
    "  if($position le 1 or empty($inserts)) then ($inserts, $target)\n"
    "  else (head($target), insert-before(tail($target), $position - 1, $inserts))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "remove", 2, false, 355, 1,
    "declare %xqilla:inline\n"
    "function remove($target as item()*, $position as xs:integer) as item()*\n"
    "{\n"
    "  $target[position() ne $position]\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "reverse", 1, false, 361, 1,
    "declare function reverse($seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then ()\n"
    "  else (reverse(tail($seq)), head($seq))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "subsequence", 2, false, 368, 1,
    "declare %xqilla:inline\n"
    "function subsequence($sourceSeq as item()*, $startingLoc as xs:double) as item()*\n"
    "{\n"
    "  let $s := round($startingLoc)\n"
    "  return\n"
    "    if($s < 1) then $sourceSeq\n"
    "    else xqilla:drop($sourceSeq, $s - 1)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "subsequence", 3, false, 377, 1,
    "declare %xqilla:inline\n"
    "function subsequence($sourceSeq as item()*, $startingLoc as xs:double,\n"
    "  $length as xs:double) as item()*\n"
    "{\n"
    "  let $s := round($startingLoc)\n"
    "  return\n"
    "    if($s < 1) then take($sourceSeq, round($length) + $s - 1)\n"
    "    else take(xqilla:drop($sourceSeq, $s - 1), round($length))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "subsequence-helper", 2, true, 388, 1,
    "declare %private (: %xqilla:inline-if-constant(\"start\") :)\n"
    "function subsequence-helper($seq as item()*, $start as xs:double) as item()*\n"
    "{\n"
    "  if($start le 1) then $seq\n"
    "  else subsequence-helper(tail($seq), $start - 1)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "take", 2, true, 396, 1,
    "declare %private\n"
    "function take($seq as item()*, $num as xs:double) as item()*\n"
    "{\n"
    "  if($num le 0 or empty($seq)) then ()\n"
    "  else (head($seq), take(tail($seq), $num - 1))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "deep-equal", 2, false, 403, 1,
    "declare %xqilla:inline\n"
    "function deep-equal($parameter1 as item()*, $parameter2 as item()*) as xs:boolean\n"
    "{\n"
    "  deep-equal($parameter1, $parameter2, default-collation())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "deep-equal", 3, false, 409, 1,
    "declare function deep-equal($p1 as item()*, $p2 as item()*, $collation as xs:string) as xs:boolean\n"
    "{\n"
    "  if(empty($p1)) then empty($p2) else\n"
    "  if(empty($p2)) then false() else\n"
    "\n"
    "  let $i1 := head($p1), $i2 := head($p2)\n"
    "  return\n"
    "    typeswitch($i1)\n"
    "\n"
    "    case $a1 as xs:anyAtomicType return\n"
    "      typeswitch($i2)\n"
    "      case $a2 as xs:anyAtomicType return\n"
    "        empty(tail(distinct-values(($a1, $a2), $collation))) and\n"
    "        deep-equal(tail($p1), tail($p2), $collation)\n"
    "      case node() return false()\n"
    "      default return deep-equal-error()\n"
    "\n"
    "    case $n1 as node() return (\n"
    "      typeswitch($i2)\n"
    "      case xs:anyAtomicType return false()\n"
    "      case $n2 as node() return (\n"
    "        deep-equal-nodes($n1, $n2, $collation) and\n"
    "        deep-equal(tail($p1), tail($p2), $collation)\n"
    "      )\n"
    "      default return deep-equal-error()\n"
    "    )\n"
    "\n"
    "    default return deep-equal-error()\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "deep-equal-error", 0, true, 439, 1,
    "declare %private %xqilla:inline\n"
    "function deep-equal-error()\n"
    "{\n"
    "  error(xs:QName(\"err:FOTY0015\"), \"An argument to fn:deep-equal() contains a function item\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "deep-equal-nodes", 3, true, 445, 1,
    "declare %private\n"
    "function deep-equal-nodes($p1 as node()*, $p2 as node()*, $collation as xs:string) as xs:boolean\n"
    "{\n"
    "  if(empty($p1)) then empty($p2) else\n"
    "  if(empty($p2)) then false() else\n"
    "\n"
    "  let $i1 := head($p1), $i2 := head($p2)\n"
    "  return\n"
    "  typeswitch($i1)\n"
    "\n"
    "  case document-node() return\n"
    "    typeswitch($i2)\n"
    "    case document-node() return\n"
    "      deep-equal-nodes($i1/(*|text()), $i2/(*|text()), $collation) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case text() return\n"
    "    typeswitch($i2)\n"
    "    case text() return\n"
    "      empty(tail(distinct-values(($i1, $i2), $collation))) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case comment() return\n"
    "    typeswitch($i2)\n"
    "    case comment() return\n"
    "      empty(tail(distinct-values(($i1, $i2), $collation))) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case processing-instruction() return\n"
    "    typeswitch($i2)\n"
    "    case processing-instruction() return\n"
    "      node-name($i1) eq node-name($i2) and\n"
    "      empty(tail(distinct-values(($i1, $i2), $collation))) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case attribute() return\n"
    "    typeswitch($i2)\n"
    "    case attribute() return\n"
    "      node-name($i1) eq node-name($i2) and\n"
    "      deep-equal(data($i1), data($i2), $collation) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "\n"
    "  case element() return\n"
    "    typeswitch($i2)\n"
    "    case element() return (\n"
    "      node-name($i1) eq node-name($i2) and\n"
    "      count($i1/@*) eq count($i2/@*) and\n"
    "      (every $a1 in $i1/@* satisfies\n"
    "        some $a2 in $i2/@* satisfies deep-equal-nodes($a1, $a2, $collation)) and\n"
    "\n"
    "      (if(empty($i1/*) and empty($i2/*))\n"
    "        then deep-equal(data($i1), data($i2), $collation)\n"
    "        else deep-equal-nodes($i1/(*|text()), $i2/(*|text()), $collation)) and\n"
    "\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    )\n"
    "    default return false()\n"
    "\n"
    "  \n"
    "  default (: namespace-node() :) return\n"
    "    typeswitch($i2)\n"
    "    case namespace-node() return\n"
    "      deep-equal(node-name($i1), node-name($i2), $collation) and\n"
    "      codepoint-equal($i1, $i2) and\n"
    "      deep-equal-nodes(tail($p1), tail($p2), $collation)\n"
    "    default return false()\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "avg", 1, false, 521, 1,
    "declare %xqilla:inline\n"
    "function avg($arg as xs:anyAtomicType*) as xs:anyAtomicType?\n"
    "{\n"
    "  sum($arg, ()) div count($arg)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "sum", 1, false, 527, 1,
    "declare %xqilla:inline\n"
    "function sum($arg as xs:anyAtomicType*) as xs:anyAtomicType\n"
    "{\n"
    "  sum($arg, 0)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "sum", 2, false, 533, 1,
    "declare function sum($arg as xs:anyAtomicType*, $zero as xs:anyAtomicType?) as xs:anyAtomicType?\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $zero\n"
    "  case $head as xs:untypedAtomic return numeric-sum(tail($arg), xs:double($head))\n"
    "  case $head as xs:double | xs:float | xs:decimal return\n"
    "    if($head ne $head) then $head else numeric-sum(tail($arg), $head)\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-sum(tail($arg), $head)\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-sum(tail($arg), $head)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Invalid argument to fn:sum() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "numeric-sum", 2, true, 545, 1,
    "declare %private function numeric-sum($arg as xs:anyAtomicType*, $result as xs:anyAtomicType) as xs:anyAtomicType\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic return numeric-sum(tail($arg), xs:double($head) + $result)\n"
    "  case $head as xs:double | xs:float | xs:decimal return\n"
    "    if($head ne $head) then $head else numeric-sum(tail($arg), $head + $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Invalid argument to fn:sum() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "yearMonthDuration-sum", 2, true, 555, 1,
    "declare %private function yearMonthDuration-sum($arg as xs:anyAtomicType*, $result as xs:yearMonthDuration) as xs:yearMonthDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-sum(tail($arg), $head + $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Invalid argument to fn:sum() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "dayTimeDuration-sum", 2, true, 563, 1,
    "declare %private function dayTimeDuration-sum($arg as xs:anyAtomicType*, $result as xs:dayTimeDuration) as xs:dayTimeDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-sum(tail($arg), $head + $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Invalid argument to fn:sum() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "max", 1, false, 571, 1,
    "declare %xqilla:inline\n"
    "function max($arg as xs:anyAtomicType*) as xs:anyAtomicType?\n"
    "{\n"
    "  max($arg, default-collation())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "max", 2, false, 577, 1,
    "declare function max($arg as xs:anyAtomicType*, $collation as xs:string) as xs:anyAtomicType?\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return ()\n"
    "  case $head as xs:untypedAtomic | xs:double return double-max(tail($arg), xs:double($head))\n"
    "  case $head as xs:float return float-max(tail($arg), $head)\n"
    "  case $head as xs:decimal return decimal-max(tail($arg), $head)\n"
    "  case $head as xs:anyURI | xs:string return string-max(tail($arg), xs:string($head), $collation)\n"
    "  case $head as xs:boolean return boolean-max(tail($arg), $head)\n"
    "  case $head as xs:date return date-max(tail($arg), $head)\n"
    "  case $head as xs:time return time-max(tail($arg), $head)\n"
    "  case $head as xs:dateTime return dateTime-max(tail($arg), $head)\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-max(tail($arg), $head)\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-max(tail($arg), $head)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "double-max", 2, true, 594, 1,
    "declare %private function double-max($arg as xs:anyAtomicType*, $result as xs:double) as xs:double\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic | xs:double | xs:float | xs:decimal return\n"
    "    let $head := xs:double($head) return\n"
    "      double-max(tail($arg), if($head gt $result or $head ne $head) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "float-max", 2, true, 604, 1,
    "declare %private function float-max($arg as xs:anyAtomicType*, $result as xs:float) as xs:anyAtomicType\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic | xs:double return double-max($arg, xs:double($result))\n"
    "  case $head as xs:float | xs:decimal return\n"
    "    let $head := xs:float($head) return\n"
    "      float-max(tail($arg), if($head gt $result or $head ne $head) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decimal-max", 2, true, 615, 1,
    "declare %private function decimal-max($arg as xs:anyAtomicType*, $result as xs:decimal) as xs:anyAtomicType\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic | xs:double return double-max($arg, xs:double($result))\n"
    "  case $head as xs:float return float-max($arg, xs:float($result))\n"
    "  case $head as xs:decimal return decimal-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "string-max", 3, true, 625, 1,
    "declare %private function string-max($arg as xs:anyAtomicType*, $result as xs:string, $collation as xs:string) as xs:string\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:string | xs:anyURI return\n"
    "    string-max(tail($arg), if(compare($head, $result, $collation) gt 0) then xs:string($head) else $result, $collation)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "boolean-max", 2, true, 634, 1,
    "declare %private function boolean-max($arg as xs:anyAtomicType*, $result as xs:boolean) as xs:boolean\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:boolean return boolean-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "date-max", 2, true, 642, 1,
    "declare %private function date-max($arg as xs:anyAtomicType*, $result as xs:date) as xs:date\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:date return date-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "time-max", 2, true, 650, 1,
    "declare %private function time-max($arg as xs:anyAtomicType*, $result as xs:time) as xs:time\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:time return time-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "dateTime-max", 2, true, 658, 1,
    "declare %private function dateTime-max($arg as xs:anyAtomicType*, $result as xs:dateTime) as xs:dateTime\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:dateTime return dateTime-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "yearMonthDuration-max", 2, true, 666, 1,
    "declare %private function yearMonthDuration-max($arg as xs:anyAtomicType*, $result as xs:yearMonthDuration) as xs:yearMonthDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "dayTimeDuration-max", 2, true, 674, 1,
    "declare %private function dayTimeDuration-max($arg as xs:anyAtomicType*, $result as xs:dayTimeDuration) as xs:dayTimeDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-max(tail($arg), if($head gt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:max() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "min", 1, false, 682, 1,
    "declare %xqilla:inline\n"
    "function min($arg as xs:anyAtomicType*) as xs:anyAtomicType?\n"
    "{\n"
    "  min($arg, default-collation())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "min", 2, false, 688, 1,
    "declare function min($arg as xs:anyAtomicType*, $collation as xs:string) as xs:anyAtomicType?\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return ()\n"
    "  case $head as xs:untypedAtomic | xs:double return double-min(tail($arg), xs:double($head))\n"
    "  case $head as xs:float return float-min(tail($arg), $head)\n"
    "  case $head as xs:decimal return decimal-min(tail($arg), $head)\n"
    "  case $head as xs:anyURI | xs:string return string-min(tail($arg), xs:string($head), $collation)\n"
    "  case $head as xs:boolean return boolean-min(tail($arg), $head)\n"
    "  case $head as xs:date return date-min(tail($arg), $head)\n"
    "  case $head as xs:time return time-min(tail($arg), $head)\n"
    "  case $head as xs:dateTime return dateTime-min(tail($arg), $head)\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-min(tail($arg), $head)\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-min(tail($arg), $head)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "double-min", 2, true, 705, 1,
    "declare %private function double-min($arg as xs:anyAtomicType*, $result as xs:double) as xs:double\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic | xs:double | xs:float | xs:decimal return\n"
    "    let $head := xs:double($head) return\n"
    "      double-min(tail($arg), if($head lt $result or $head ne $head) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "float-min", 2, true, 715, 1,
    "declare %private function float-min($arg as xs:anyAtomicType*, $result as xs:float) as xs:anyAtomicType\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic | xs:double return double-min($arg, xs:double($result))\n"
    "  case $head as xs:float | xs:decimal return\n"
    "    let $head := xs:float($head) return\n"
    "      float-min(tail($arg), if($head lt $result or $head ne $head) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decimal-min", 2, true, 726, 1,
    "declare %private function decimal-min($arg as xs:anyAtomicType*, $result as xs:decimal) as xs:anyAtomicType\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:untypedAtomic | xs:double return double-min($arg, xs:double($result))\n"
    "  case $head as xs:float return float-min($arg, xs:float($result))\n"
    "  case $head as xs:decimal return decimal-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "string-min", 3, true, 736, 1,
    "declare %private function string-min($arg as xs:anyAtomicType*, $result as xs:string, $collation as xs:string) as xs:string\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:string | xs:anyURI return\n"
    "    string-min(tail($arg), if(compare($head, $result, $collation) lt 0) then xs:string($head) else $result, $collation)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "boolean-min", 2, true, 745, 1,
    "declare %private function boolean-min($arg as xs:anyAtomicType*, $result as xs:boolean) as xs:boolean\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:boolean return boolean-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "date-min", 2, true, 753, 1,
    "declare %private function date-min($arg as xs:anyAtomicType*, $result as xs:date) as xs:date\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:date return date-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "time-min", 2, true, 761, 1,
    "declare %private function time-min($arg as xs:anyAtomicType*, $result as xs:time) as xs:time\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:time return time-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "dateTime-min", 2, true, 769, 1,
    "declare %private function dateTime-min($arg as xs:anyAtomicType*, $result as xs:dateTime) as xs:dateTime\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:dateTime return dateTime-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "yearMonthDuration-min", 2, true, 777, 1,
    "declare %private function yearMonthDuration-min($arg as xs:anyAtomicType*, $result as xs:yearMonthDuration) as xs:yearMonthDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:yearMonthDuration return yearMonthDuration-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "dayTimeDuration-min", 2, true, 785, 1,
    "declare %private function dayTimeDuration-min($arg as xs:anyAtomicType*, $result as xs:dayTimeDuration) as xs:dayTimeDuration\n"
    "{\n"
    "  typeswitch(head($arg))\n"
    "  case empty-sequence() return $result\n"
    "  case $head as xs:dayTimeDuration return dayTimeDuration-min(tail($arg), if($head lt $result) then $head else $result)\n"
    "  default return error(xs:QName(\"err:FORG0006\"), \"Uncomparable items in argument to fn:min() function\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-get", 2, false, 796, 1,
    "declare %xqilla:inline\n"
    "function map-get($map as map(), $key as xs:anyAtomicType) as item()*\n"
    "{\n"
    "  $map($key)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-keys", 1, false, 802, 1,
    "declare function map-keys($map as map()) as xs:anyAtomicType*\n"
    "{\n"
    "  map(map-get(?, \"key\"), map-entries($map))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-fold", 3, false, 807, 1,
    "declare function map-fold(\n"
    "  $f as function(item()*, xs:anyAtomicType, item()*) as item()*,\n"
    "  $z as item()*,\n"
    "  $map as map()\n"
    ") as item()*\n"
    "{\n"
    "  fold-left(function($r, $e as map()) { $f($r, $e(\"key\"), $e(\"value\")) },\n"
    "    $z, map-entries($map))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-put", 2, true, 817, 1,
    "declare %private \n"
    "function map-put($map as map(), $entry as map()) as map()\n"
    "{\n"
    "  map-put($map, $entry(\"key\"), $entry(\"value\"))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-new", 1, false, 823, 1,
    "declare %xqilla:inline\n"
    "function map-new($maps as map()*) as map()\n"
    "{\n"
    "  if(empty($maps)) then empty-map() else\n"
    "  fold-left(map-put#2, head($maps), map(map-entries#1, tail($maps)))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-new", 2, false, 830, 1,
    "declare %xqilla:inline\n"
    "function map-new($maps as map()*, $collation as xs:string) as map()\n"
    "{\n"
    "  fold-left(map-put#2, empty-map($collation), map(map-entries#1, $maps))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map", 2, false, 839, 1,
    "declare function map($f as function(item()) as item()*, $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then ()\n"
    "  else ($f(head($seq)), map($f, tail($seq)))\n"
    "}"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 845, 25,
    "fn:MapMapFusion:\n"
    "map(~f, map(~g, ~e)) -> map(function($a) { map(~f,~g($a)) }, ~e)"
  },
  {
    DelayedModule::Decl::REWRITE_RULE, "", 0, false, 848, 25,
    "fn:MapSingleton:\n"
    "map(~f, ~e) where rw:subtype(~e, 'item()') -> ~f(~e)"
  },
  {
    DelayedModule::Decl::FUNCTION, "filter", 2, false, 851, 1,
    "declare function filter($f as function(item()) as xs:boolean, $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then ()\n"
    "  else (\n"
    "    if($f(head($seq))) then head($seq) else (),\n"
    "    filter($f, tail($seq))\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "fold-left", 3, false, 860, 1,
    "declare function fold-left($f as function(item()*, item()) as item()*, $zero as item()*,\n"
    "  $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then $zero\n"
    "  else fold-left($f, $f($zero, head($seq)), tail($seq))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "fold-right", 3, false, 867, 1,
    "declare function fold-right($f as function(item(), item()*) as item()*, $zero as item()*,\n"
    "  $seq as item()*) as item()*\n"
    "{\n"
    "  if(empty($seq)) then $zero\n"
    "  else $f(head($seq), fold-right($f, $zero, tail($seq)))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "map-pairs", 3, false, 874, 1,
    "declare function map-pairs($f as function(item(), item()) as item()*, $seq1 as item()*,\n"
    "  $seq2 as item()*) as item()*\n"
    "{\n"
    "   if(empty($seq1) or empty($seq2)) then ()\n"
    "   else (\n"
    "     $f(head($seq1), head($seq2)),\n"
    "     map-pairs($f, tail($seq1), tail($seq2))\n"
    "   )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "round", 2, false, 884, 1,
    "declare %xqilla:inline\n"
    "function round($arg as xs:anyAtomicType?, $precision as xs:integer) as xs:anyAtomicType?\n"
    "{\n"
    "  let $factor := math:exp10($precision)\n"
    "  return round($arg * $factor) div $factor\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "round-half-to-even", 2, false, 891, 1,
    "declare %xqilla:inline\n"
    "function round-half-to-even($arg as xs:anyAtomicType?, $precision as xs:integer) as xs:anyAtomicType?\n"
    "{\n"
    "  let $factor := math:exp10($precision)\n"
    "  return round-half-to-even($arg * $factor) div $factor\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "has-children", 1, false, 898, 1,
    "declare %xqilla:inline\n"
    "function has-children($node as node()?) as xs:boolean\n"
    "{\n"
    "  exists($node/child::node())\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "innermost", 1, false, 904, 1,
    "declare %xqilla:inline\n"
    "function innermost($nodes as node()*) as node()*\n"
    "{\n"
    "  $nodes except $nodes/ancestor::node()\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "outermost", 1, false, 910, 1,
    "declare %xqilla:inline\n"
    "function outermost($nodes as node()*) as node()*\n"
    "{\n"
    "  $nodes[not(ancestor::node() intersect $nodes)]\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "element-with-id", 2, false, 922, 1,
    "declare %xqilla:inline\n"
    "function element-with-id($arg as xs:string*, $node as node()) as element()*\n"
    "{\n"
    "  for $e in id($arg, $node)\n"
    "  return typeswitch($e)\n"
    "    case element(*, xs:ID) return $e/..\n"
    "    default return $e\n"
    "}"
  },
  { DelayedModule::Decl::NONE, 0, 0, 0, 0, 0 }
};

static const DelayedModule fn_module = { fn_file, fn_prefix, fn_uri, fn_declarations };
