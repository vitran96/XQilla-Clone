// Auto-generated by compile-delayed-module from ../src/functions/XQillaModule.xq
// DO NOT EDIT

// ../src/functions/XQillaModule.xq
static const XMLCh xqilla_file[] = { 46, 46, 47, 115, 114, 99, 47, 102, 117, 110, 99, 116, 105, 111, 110, 115, 47, 88, 81, 105, 108, 108, 97, 77, 111, 100, 117, 108, 101, 46, 120, 113, 0 };

// xqilla
static const XMLCh xqilla_prefix[] = { 120, 113, 105, 108, 108, 97, 0 };

// http://xqilla.sourceforge.net/Functions
static const XMLCh xqilla_uri[] = { 104, 116, 116, 112, 58, 47, 47, 120, 113, 105, 108, 108, 97, 46, 115, 111, 117, 114, 99, 101, 102, 111, 114, 103, 101, 46, 110, 101, 116, 47, 70, 117, 110, 99, 116, 105, 111, 110, 115, 0 };

static const DelayedModule::Decl xqilla_declarations[] = {
  {
    DelayedModule::Decl::FUNCTION, "parse-json", 1, false, 8, 1,
    "declare function xqilla:parse-json($json as xs:string)\n"
    "  as element()?\n"
    "{\n"
    "  let $res := xqilla:parseValue(xqilla:tokenize($json))\n"
    "  return\n"
    "    if(exists(remove($res,1))) then xqilla:parseError($res[2])\n"
    "    else element json {\n"
    "      $res[1]/@*,\n"
    "      $res[1]/node()\n"
    "    }\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseValue", 1, true, 20, 1,
    "declare %private function xqilla:parseValue($tokens as element(token)*)\n"
    "{\n"
    "  let $token := $tokens[1]\n"
    "  let $tokens := remove($tokens,1)\n"
    "  return\n"
    "    if($token/@t = \"lbrace\") then (\n"
    "      let $res := xqilla:parseObject($tokens)\n"
    "      let $tokens := remove($res,1)\n"
    "      return (\n"
    "        element res {\n"
    "          attribute type { \"object\" },\n"
    "          $res[1]/node()\n"
    "        },\n"
    "        $tokens\n"
    "      )\n"
    "    ) else if ($token/@t = \"lsquare\") then (\n"
    "      let $res := xqilla:parseArray($tokens)\n"
    "      let $tokens := remove($res,1)\n"
    "      return (\n"
    "        element res {\n"
    "          attribute type { \"array\" },\n"
    "          $res[1]/node()\n"
    "        },\n"
    "        $tokens\n"
    "      )\n"
    "    ) else if ($token/@t = \"number\") then (\n"
    "      element res {\n"
    "        attribute type { \"number\" },\n"
    "        text { $token }\n"
    "      },\n"
    "      $tokens\n"
    "    ) else if ($token/@t = \"string\") then (\n"
    "      element res {\n"
    "        attribute type { \"string\" },\n"
    "        text { xqilla:unescape-json-string($token) }\n"
    "      },\n"
    "      $tokens\n"
    "    ) else if ($token/@t = \"true\" or $token/@t = \"false\") then (\n"
    "      element res {\n"
    "        attribute type { \"boolean\" },\n"
    "        text { $token }\n"
    "      },\n"
    "      $tokens\n"
    "    ) else if ($token/@t = \"null\") then (\n"
    "      element res {\n"
    "        attribute type { \"null\" }\n"
    "      },\n"
    "      $tokens\n"
    "    ) else xqilla:parseError($token)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseObject", 1, true, 71, 1,
    "declare %private function xqilla:parseObject($tokens as element(token)*)\n"
    "{\n"
    "  let $token1 := $tokens[1]\n"
    "  let $tokens := remove($tokens,1)\n"
    "  return\n"
    "    if(not($token1/@t = \"string\")) then xqilla:parseError($token1) else\n"
    "      let $token2 := $tokens[1]\n"
    "      let $tokens := remove($tokens,1)\n"
    "      return\n"
    "        if(not($token2/@t = \"colon\")) then xqilla:parseError($token2) else\n"
    "          let $res := xqilla:parseValue($tokens)\n"
    "          let $tokens := remove($res,1)\n"
    "          let $pair := element pair {\n"
    "            attribute name { $token1 },\n"
    "            $res[1]/@*,\n"
    "            $res[1]/node()\n"
    "          }\n"
    "          let $token := $tokens[1]\n"
    "          let $tokens := remove($tokens,1)\n"
    "          return\n"
    "            if($token/@t = \"comma\") then (\n"
    "              let $res := xqilla:parseObject($tokens)\n"
    "              let $tokens := remove($res,1)\n"
    "              return (\n"
    "                element res {\n"
    "                  $pair,\n"
    "                  $res[1]/node()\n"
    "                },\n"
    "                $tokens\n"
    "              )\n"
    "            ) else if($token/@t = \"rbrace\") then (\n"
    "              element res {\n"
    "                $pair\n"
    "              },\n"
    "              $tokens\n"
    "            ) else xqilla:parseError($token)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseArray", 1, true, 109, 1,
    "declare %private function xqilla:parseArray($tokens as element(token)*)\n"
    "{\n"
    "  let $res := xqilla:parseValue($tokens)\n"
    "  let $tokens := remove($res,1)\n"
    "  let $item := element item {\n"
    "    $res[1]/@*,\n"
    "    $res[1]/node()\n"
    "  }\n"
    "  let $token := $tokens[1]\n"
    "  let $tokens := remove($tokens,1)\n"
    "  return\n"
    "    if($token/@t = \"comma\") then (\n"
    "      let $res := xqilla:parseArray($tokens)\n"
    "      let $tokens := remove($res,1)\n"
    "      return (\n"
    "        element res {\n"
    "          $item,\n"
    "          $res[1]/node()\n"
    "        },\n"
    "        $tokens\n"
    "      )\n"
    "    ) else if($token/@t = \"rsquare\") then (\n"
    "      element res {\n"
    "        $item\n"
    "      },\n"
    "      $tokens\n"
    "    ) else xqilla:parseError($token)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseError", 1, true, 138, 1,
    "declare %private function xqilla:parseError($token as element(token))\n"
    "  as empty-sequence()\n"
    "{\n"
    "  error(xs:QName(\"xqilla:PARSEJSON01\"),\n"
    "    concat(\"Unexpected token: \", string($token/@t), \" (\"\"\", string($token), \"\"\")\"))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "tokenize", 1, true, 145, 1,
    "declare %private function xqilla:tokenize($json as xs:string)\n"
    "  as element(token)*\n"
    "{\n"
    "  let $tokens := (\"\\{\", \"\\}\", \"\\[\", \"\\]\", \":\", \",\", \"true\", \"false\", \"null\", \"\\s+\",\n"
    "    '\"([^\"\\\\]|\\\\\"|\\\\\\\\|\\\\/|\\\\b|\\\\f|\\\\n|\\\\r|\\\\t|\\\\u[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9])*\"',\n"
    "    \"-?(0|[1-9][0-9]*)(\\.[0-9]+)?([eE][+-]?[0-9]+)?\")\n"
    "  let $regex := string-join(for $t in $tokens return concat(\"(\",$t,\")\"),\"|\")\n"
    "  for $match in analyze-string($json, $regex)/*\n"
    "  return\n"
    "    if($match/self::*:non-match) then xqilla:token(\"error\", string($match))\n"
    "    else if($match/*:group/@nr = 1) then xqilla:token(\"lbrace\", string($match))\n"
    "    else if($match/*:group/@nr = 2) then xqilla:token(\"rbrace\", string($match))\n"
    "    else if($match/*:group/@nr = 3) then xqilla:token(\"lsquare\", string($match))\n"
    "    else if($match/*:group/@nr = 4) then xqilla:token(\"rsquare\", string($match))\n"
    "    else if($match/*:group/@nr = 5) then xqilla:token(\"colon\", string($match))\n"
    "    else if($match/*:group/@nr = 6) then xqilla:token(\"comma\", string($match))\n"
    "    else if($match/*:group/@nr = 7) then xqilla:token(\"true\", string($match))\n"
    "    else if($match/*:group/@nr = 8) then xqilla:token(\"false\", string($match))\n"
    "    else if($match/*:group/@nr = 9) then xqilla:token(\"null\", string($match))\n"
    "    else if($match/*:group/@nr = 10) then () (:ignore whitespace:)\n"
    "    else if($match/*:group/@nr = 11) then\n"
    "      let $v := string($match)\n"
    "      let $len := string-length($v)\n"
    "      return xqilla:token(\"string\", substring($v, 2, $len - 2))\n"
    "    else if($match/*:group/@nr = 13) then xqilla:token(\"number\", string($match))\n"
    "    else xqilla:token(\"error\", string($match))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "token", 2, true, 173, 1,
    "declare %private function xqilla:token($t, $value)\n"
    "{\n"
    "  <token t=\"{$t}\">{ string($value) }</token>\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serialize-json", 1, false, 181, 1,
    "declare function xqilla:serialize-json($json-xml as element()?)\n"
    "  as xs:string?\n"
    "{\n"
    "  if(empty($json-xml)) then () else\n"
    "\n"
    "  string-join(\n"
    "    xqilla:serializeJSONElement($json-xml)\n"
    "  ,\"\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serializeJSONElement", 1, true, 191, 1,
    "declare %private function xqilla:serializeJSONElement($e as element())\n"
    "  as xs:string*\n"
    "{\n"
    "  if($e/@type = \"object\") then xqilla:serializeJSONObject($e)\n"
    "  else if($e/@type = \"array\") then xqilla:serializeJSONArray($e)\n"
    "  else if($e/@type = \"null\") then \"null\"\n"
    "  else if($e/@type = \"boolean\") then string($e)\n"
    "  else if($e/@type = \"number\") then string($e)\n"
    "  else ('\"', xqilla:escape-json-string($e), '\"')\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serializeJSONObject", 1, true, 202, 1,
    "declare %private function xqilla:serializeJSONObject($e as element())\n"
    "  as xs:string*\n"
    "{\n"
    "  \"{\",\n"
    "  $e/*/(\n"
    "    if(position() = 1) then () else \",\",\n"
    "    '\"', xqilla:escape-json-string(@name), '\":',\n"
    "    xqilla:serializeJSONElement(.)\n"
    "  ),\n"
    "  \"}\"\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serializeJSONArray", 1, true, 214, 1,
    "declare %private function xqilla:serializeJSONArray($e as element())\n"
    "  as xs:string*\n"
    "{\n"
    "  \"[\",\n"
    "  $e/*/(\n"
    "    if(position() = 1) then () else \",\",\n"
    "    xqilla:serializeJSONElement(.)\n"
    "  ),\n"
    "  \"]\"\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "unescape-json-string", 1, false, 228, 1,
    "declare function xqilla:unescape-json-string($val as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  string-join(\n"
    "    let $regex := '[^\\\\]+|(\\\\\")|(\\\\\\\\)|(\\\\/)|(\\\\b)|(\\\\f)|(\\\\n)|(\\\\r)|(\\\\t)|(\\\\u[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9])'\n"
    "    for $match in analyze-string($val, $regex)/*\n"
    "    return\n"
    "      if($match/*:group/@nr = 1) then \"\"\"\"\n"
    "      else if($match/*:group/@nr = 2) then \"\\\"\n"
    "      else if($match/*:group/@nr = 3) then \"/\"\n"
    "      (: else if($match/*:group/@nr = 4) then \"&#x08;\" :)\n"
    "      (: else if($match/*:group/@nr = 5) then \"&#x0C;\" :)\n"
    "      else if($match/*:group/@nr = 6) then \"&#x0A;\"\n"
    "      else if($match/*:group/@nr = 7) then \"&#x0D;\"\n"
    "      else if($match/*:group/@nr = 8) then \"&#x09;\"\n"
    "      else if($match/*:group/@nr = 9) then\n"
    "        codepoints-to-string(xqilla:decode-hex-string(substring($match, 3)))\n"
    "      else string($match)\n"
    "  ,\"\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "escape-json-string", 1, false, 249, 1,
    "declare function xqilla:escape-json-string($val as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  string-join(\n"
    "    let $regex := '(\")|(\\\\)|(/)|(&#x0A;)|(&#x0D;)|(&#x09;)|[^\"\\\\/&#x0A;&#x0D;&#x09;]+'\n"
    "    for $match in analyze-string($val, $regex)/*\n"
    "    return\n"
    "      if($match/*:group/@nr = 1) then \"\\\"\"\"\n"
    "      else if($match/*:group/@nr = 2) then \"\\\\\"\n"
    "      else if($match/*:group/@nr = 3) then \"\\/\"\n"
    "      else if($match/*:group/@nr = 4) then \"\\n\"\n"
    "      else if($match/*:group/@nr = 5) then \"\\r\"\n"
    "      else if($match/*:group/@nr = 6) then \"\\t\"\n"
    "      else string($match)\n"
    "  ,\"\")\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decode-hex-string", 1, false, 265, 1,
    "declare function xqilla:decode-hex-string($val as xs:string)\n"
    "  as xs:integer\n"
    "{\n"
    "  xqilla:decodeHexStringHelper(string-to-codepoints($val), 0)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decodeHexChar", 1, true, 271, 1,
    "declare %private function xqilla:decodeHexChar($val as xs:integer)\n"
    "  as xs:integer\n"
    "{\n"
    "  let $tmp := $val - 48 (: '0' :)\n"
    "  let $tmp := if($tmp <= 9) then $tmp else $tmp - (65-48) (: 'A'-'0' :)\n"
    "  let $tmp := if($tmp <= 15) then $tmp else $tmp - (97-65) (: 'a'-'A' :)\n"
    "  return $tmp\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decodeHexStringHelper", 2, true, 280, 1,
    "declare %private function xqilla:decodeHexStringHelper($chars as xs:integer*, $acc as xs:integer)\n"
    "  as xs:integer\n"
    "{\n"
    "  if(empty($chars)) then $acc\n"
    "  else xqilla:decodeHexStringHelper(remove($chars,1), ($acc * 16) + xqilla:decodeHexChar($chars[1]))\n"
    "}"
  },
  { DelayedModule::Decl::NONE, 0, 0, 0, 0, 0 }
};

static const DelayedModule xqilla_module = { xqilla_file, xqilla_prefix, xqilla_uri, xqilla_declarations };
