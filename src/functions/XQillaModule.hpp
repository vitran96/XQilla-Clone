// Auto-generated by compile-delayed-module from ../src/functions/XQillaModule.xq
// DO NOT EDIT

// ../src/functions/XQillaModule.xq
static const XMLCh xqilla_file[] = { 46, 46, 47, 115, 114, 99, 47, 102, 117, 110, 99, 116, 105, 111, 110, 115, 47, 88, 81, 105, 108, 108, 97, 77, 111, 100, 117, 108, 101, 46, 120, 113, 0 };

// xqilla
static const XMLCh xqilla_prefix[] = { 120, 113, 105, 108, 108, 97, 0 };

// http://xqilla.sourceforge.net/Functions
static const XMLCh xqilla_uri[] = { 104, 116, 116, 112, 58, 47, 47, 120, 113, 105, 108, 108, 97, 46, 115, 111, 117, 114, 99, 101, 102, 111, 114, 103, 101, 46, 110, 101, 116, 47, 70, 117, 110, 99, 116, 105, 111, 110, 115, 0 };

static const DelayedModule::Decl xqilla_declarations[] = {
  {
    DelayedModule::Decl::FUNCTION, "parse-json", 1, false, 25, 1,
    "declare function xqilla:parse-json($json as xs:string)\n"
    "  as element()?\n"
    "{\n"
    "  let $res := xqilla:parseValue(xqilla:tokenize($json))\n"
    "  return\n"
    "    if(empty(tail($res))) then head($res)\n"
    "    else xqilla:parseError($res[2])\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseValue", 1, true, 34, 1,
    "declare %private function xqilla:parseValue($tokens as element(token)*)\n"
    "{\n"
    "  let $token := head($tokens)\n"
    "  let $tokens := tail($tokens)\n"
    "  return\n"
    "    switch($token/@t)\n"
    "    case \"lbrace\" return\n"
    "      let $res := xqilla:parseObject($tokens)\n"
    "      let $tokens := tail($res)\n"
    "      return (\n"
    "        element json {\n"
    "          attribute type { \"object\" },\n"
    "          head($res)/node()\n"
    "        },\n"
    "        $tokens\n"
    "      )\n"
    "    case \"lsquare\" return\n"
    "      let $res := xqilla:parseArray($tokens)\n"
    "      let $tokens := tail($res)\n"
    "      return (\n"
    "        element json {\n"
    "          attribute type { \"array\" },\n"
    "          head($res)/node()\n"
    "        },\n"
    "        $tokens\n"
    "      )\n"
    "    case \"number\" return (\n"
    "      element json {\n"
    "        attribute type { \"number\" },\n"
    "        text { $token }\n"
    "      },\n"
    "      $tokens\n"
    "    )\n"
    "    case \"string\" return (\n"
    "      element json {\n"
    "        attribute type { \"string\" },\n"
    "        text { xqilla:unescape-json-string($token) }\n"
    "      },\n"
    "      $tokens\n"
    "    )\n"
    "    case \"true\"\n"
    "    case \"false\" return (\n"
    "      element json {\n"
    "        attribute type { \"boolean\" },\n"
    "        text { $token }\n"
    "      },\n"
    "      $tokens\n"
    "    )\n"
    "    case \"null\" return (\n"
    "      element json {\n"
    "        attribute type { \"null\" }\n"
    "      },\n"
    "      $tokens\n"
    "    )\n"
    "    default return xqilla:parseError($token)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseObject", 1, true, 91, 1,
    "declare %private function xqilla:parseObject($tokens as element(token)*)\n"
    "{\n"
    "  let $token1 := head($tokens)\n"
    "  let $tokens := tail($tokens)\n"
    "  return\n"
    "    if(not($token1/@t = \"string\")) then xqilla:parseError($token1) else\n"
    "      let $token2 := head($tokens)\n"
    "      let $tokens := tail($tokens)\n"
    "      return\n"
    "        if(not($token2/@t = \"colon\")) then xqilla:parseError($token2) else\n"
    "          let $res := xqilla:parseValue($tokens)\n"
    "          let $tokens := tail($res)\n"
    "          let $pair := element pair {\n"
    "            attribute name { $token1 },\n"
    "            head($res)/(@*,node())\n"
    "          }\n"
    "          let $token := head($tokens)\n"
    "          let $tokens := tail($tokens)\n"
    "          return\n"
    "            switch($token/@t)\n"
    "            case \"comma\" return\n"
    "              let $res := xqilla:parseObject($tokens)\n"
    "              let $tokens := tail($res)\n"
    "              return (\n"
    "                element json {\n"
    "                  $pair,\n"
    "                  head($res)/node()\n"
    "                },\n"
    "                $tokens\n"
    "              )\n"
    "            case \"rbrace\" return (\n"
    "              element json {\n"
    "                $pair\n"
    "              },\n"
    "              $tokens\n"
    "            )\n"
    "            default return xqilla:parseError($token)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseArray", 1, true, 130, 1,
    "declare %private function xqilla:parseArray($tokens as element(token)*)\n"
    "{\n"
    "  let $res := xqilla:parseValue($tokens)\n"
    "  let $tokens := tail($res)\n"
    "  let $item := element item {\n"
    "    head($res)/(@*,node())\n"
    "  }\n"
    "  let $token := head($tokens)\n"
    "  let $tokens := tail($tokens)\n"
    "  return\n"
    "    switch($token/@t)\n"
    "    case \"comma\" return\n"
    "      let $res := xqilla:parseArray($tokens)\n"
    "      let $tokens := tail($res)\n"
    "      return (\n"
    "        element json {\n"
    "          $item,\n"
    "          head($res)/node()\n"
    "        },\n"
    "        $tokens\n"
    "      )\n"
    "    case \"rsquare\" return (\n"
    "      element json {\n"
    "        $item\n"
    "      },\n"
    "      $tokens\n"
    "    )\n"
    "    default return xqilla:parseError($token)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "parseError", 1, true, 160, 1,
    "declare %private function xqilla:parseError($token as element(token))\n"
    "  as empty-sequence()\n"
    "{\n"
    "  error(xs:QName(\"xqilla:PARSEJSON01\"),\n"
    "    concat(\"Unexpected token: \", string($token/@t), \" (\"\"\", string($token), \"\"\")\"))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "tokenize", 1, true, 167, 1,
    "declare %private function xqilla:tokenize($json as xs:string)\n"
    "  as element(token)*\n"
    "{\n"
    "  let $tokens := (\"\\{\", \"\\}\", \"\\[\", \"\\]\", \":\", \",\", \"true\", \"false\", \"null\", \"\\s+\",\n"
    "    '\"([^\"\\\\]|\\\\\"|\\\\\\\\|\\\\/|\\\\b|\\\\f|\\\\n|\\\\r|\\\\t|\\\\u[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9])*\"',\n"
    "    \"-?(0|[1-9][0-9]*)(\\.[0-9]+)?([eE][+-]?[0-9]+)?\")\n"
    "  let $regex := string-join(for $t in $tokens return concat(\"(\",$t,\")\"),\"|\")\n"
    "  for $match in analyze-string($json, $regex)/*\n"
    "  return\n"
    "    switch($match/*:group/@nr)\n"
    "    case \"1\" return xqilla:token(\"lbrace\", string($match))\n"
    "    case \"2\" return xqilla:token(\"rbrace\", string($match))\n"
    "    case \"3\" return xqilla:token(\"lsquare\", string($match))\n"
    "    case \"4\" return xqilla:token(\"rsquare\", string($match))\n"
    "    case \"5\" return xqilla:token(\"colon\", string($match))\n"
    "    case \"6\" return xqilla:token(\"comma\", string($match))\n"
    "    case \"7\" return xqilla:token(\"true\", string($match))\n"
    "    case \"8\" return xqilla:token(\"false\", string($match))\n"
    "    case \"9\" return xqilla:token(\"null\", string($match))\n"
    "    case \"10\" return () (:ignore whitespace:)\n"
    "    case \"11\" return\n"
    "      let $v := string($match)\n"
    "      let $len := string-length($v)\n"
    "      return xqilla:token(\"string\", substring($v, 2, $len - 2))\n"
    "    case \"13\" return xqilla:token(\"number\", string($match))\n"
    "    default return xqilla:token(\"error\", string($match))\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "token", 2, true, 195, 1,
    "declare %private function xqilla:token($t, $value)\n"
    "{\n"
    "  <token t=\"{$t}\">{ string($value) }</token>\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serialize-json", 1, false, 203, 1,
    "declare function xqilla:serialize-json($json-xml as element()?)\n"
    "  as xs:string?\n"
    "{\n"
    "  if(empty($json-xml)) then () else\n"
    "\n"
    "  string-join(\n"
    "    xqilla:serializeJSONElement($json-xml)\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serializeJSONElement", 1, true, 213, 1,
    "declare %private function xqilla:serializeJSONElement($e as element())\n"
    "  as xs:string*\n"
    "{\n"
    "  switch($e/@type)\n"
    "  case \"object\" return xqilla:serializeJSONObject($e)\n"
    "  case \"array\" return xqilla:serializeJSONArray($e)\n"
    "  case \"null\" return \"null\"\n"
    "  case \"boolean\" return string($e)\n"
    "  case \"number\" return string($e)\n"
    "  default return ('\"', xqilla:escape-json-string($e), '\"')\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serializeJSONObject", 1, true, 225, 1,
    "declare %private function xqilla:serializeJSONObject($e as element())\n"
    "  as xs:string*\n"
    "{\n"
    "  \"{\",\n"
    "  $e/*/(\n"
    "    if(position() = 1) then () else \",\",\n"
    "    '\"', xqilla:escape-json-string(@name), '\":',\n"
    "    xqilla:serializeJSONElement(.)\n"
    "  ),\n"
    "  \"}\"\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "serializeJSONArray", 1, true, 237, 1,
    "declare %private function xqilla:serializeJSONArray($e as element())\n"
    "  as xs:string*\n"
    "{\n"
    "  \"[\",\n"
    "  $e/*/(\n"
    "    if(position() = 1) then () else \",\",\n"
    "    xqilla:serializeJSONElement(.)\n"
    "  ),\n"
    "  \"]\"\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "unescape-json-string", 1, false, 251, 1,
    "declare function xqilla:unescape-json-string($val as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  string-join(\n"
    "    let $regex := '[^\\\\]+|(\\\\\")|(\\\\\\\\)|(\\\\/)|(\\\\b)|(\\\\f)|(\\\\n)|(\\\\r)|(\\\\t)|(\\\\u[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9])'\n"
    "    for $match in analyze-string($val, $regex)/*\n"
    "    return\n"
    "      switch($match/*:group/@nr)\n"
    "      case \"1\" return \"\"\"\"\n"
    "      case \"2\" return \"\\\"\n"
    "      case \"3\" return \"/\"\n"
    "      (: case \"4\" return \"&#x08;\" :)\n"
    "      (: case \"5\" return \"&#x0C;\" :)\n"
    "      case \"6\" return \"&#x0A;\"\n"
    "      case \"7\" return \"&#x0D;\"\n"
    "      case \"8\" return \"&#x09;\"\n"
    "      case \"9\" return\n"
    "        codepoints-to-string(xqilla:decode-hex-string(substring($match, 3)))\n"
    "      default return string($match)\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "escape-json-string", 1, false, 273, 1,
    "declare function xqilla:escape-json-string($val as xs:string)\n"
    "  as xs:string\n"
    "{\n"
    "  string-join(\n"
    "    let $regex := '(\")|(\\\\)|(/)|(&#x0A;)|(&#x0D;)|(&#x09;)|[^\"\\\\/&#x0A;&#x0D;&#x09;]+'\n"
    "    for $match in analyze-string($val, $regex)/*\n"
    "    return\n"
    "      switch($match/*:group/@nr)\n"
    "      case \"1\" return \"\\\"\"\"\n"
    "      case \"2\" return \"\\\\\"\n"
    "      case \"3\" return \"\\/\"\n"
    "      case \"4\" return \"\\n\"\n"
    "      case \"5\" return \"\\r\"\n"
    "      case \"6\" return \"\\t\"\n"
    "      default return string($match)\n"
    "  )\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decode-hex-string", 1, false, 290, 1,
    "declare function xqilla:decode-hex-string($val as xs:string)\n"
    "  as xs:integer\n"
    "{\n"
    "  xqilla:decodeHexStringHelper(string-to-codepoints($val), 0)\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decodeHexChar", 1, true, 296, 1,
    "declare %private function xqilla:decodeHexChar($val as xs:integer)\n"
    "  as xs:integer\n"
    "{\n"
    "  let $tmp := $val - 48 (: '0' :)\n"
    "  let $tmp := if($tmp <= 9) then $tmp else $tmp - (65-48) (: 'A'-'0' :)\n"
    "  let $tmp := if($tmp <= 15) then $tmp else $tmp - (97-65) (: 'a'-'A' :)\n"
    "  return $tmp\n"
    "}"
  },
  {
    DelayedModule::Decl::FUNCTION, "decodeHexStringHelper", 2, true, 305, 1,
    "declare %private function xqilla:decodeHexStringHelper($chars as xs:integer*, $acc as xs:integer)\n"
    "  as xs:integer\n"
    "{\n"
    "  if(empty($chars)) then $acc\n"
    "  else xqilla:decodeHexStringHelper(tail($chars), ($acc * 16) + xqilla:decodeHexChar(head($chars)))\n"
    "}"
  },
  { DelayedModule::Decl::NONE, 0, 0, 0, 0, 0 }
};

static const DelayedModule xqilla_module = { xqilla_file, xqilla_prefix, xqilla_uri, xqilla_declarations };
